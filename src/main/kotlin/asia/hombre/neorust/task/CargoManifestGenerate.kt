package asia.hombre.neorust.task

import asia.hombre.neorust.extension.CrateExtension
import asia.hombre.neorust.internal.CargoDefaultTask
import asia.hombre.neorust.options.RustBinaryOptions
import asia.hombre.neorust.options.RustManifestOptions
import org.gradle.api.provider.MapProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Input
import writeArrayField
import writeBooleanField
import writeCrateField
import writeField
import writeTable
import java.io.File
import javax.inject.Inject

abstract class CargoManifestGenerate @Inject constructor(): CargoDefaultTask() {

    @get:Input
    abstract val crateExtension: Property<CrateExtension>
    @get:Input
    abstract val rustManifestOptions: Property<RustManifestOptions>
    @get:Input
    abstract val rustBinaryOptions: Property<RustBinaryOptions>
    @get:Input
    abstract val featuresList: MapProperty<String, List<String>>

    override fun cargoTaskAction() {
        val cargoToml = File(manifestPath.get())
        //Create parent directories if they don't exist.
        cargoToml.parentFile.mkdirs()
        //Delete old Cargo.toml since it might be outdated.
        if(cargoToml.exists()) cargoToml.delete()

        val manifestOptions = rustManifestOptions.get()
        val dependencies = crateExtension.get().dependencies
        val devDependencies = crateExtension.get().devDependencies
        val buildDependencies = crateExtension.get().buildDependencies

        val content = StringBuilder()
        val packageOptions = manifestOptions.packageConfig

        content.append(
            """
                # THIS FILE IS AUTO-GENERATED by neo-rust-gradle-plugin
                # MODIFY YOUR build.gradle.kts/build.gradle FILE INSTEAD!
                # CHANGES HERE WILL BE LOST!!!
            """.trimIndent()
        )


        content.writeTable("package") {
            if(!packageOptions.name.isPresent)
                throw IllegalArgumentException("Package 'name' cannot be unset.")

            writeField("name", packageOptions.name.get())
            if(packageOptions.version.isPresent)
                writeField("version", packageOptions.version.get())
            if(packageOptions.authors.isPresent)
                writeArrayField("authors", packageOptions.authors.get())
            if(packageOptions.edition.isPresent)
                writeField("edition", packageOptions.edition.get())
            if(packageOptions.rustVersion.isPresent)
                writeField("rust-version", packageOptions.rustVersion.get())
            if(packageOptions.description.isPresent)
                writeField("description", packageOptions.description.get())
            if(packageOptions.documentation.isPresent)
                writeField("documentation", packageOptions.documentation.get())
            if(packageOptions.readme.isPresent)
                writeField("readme", packageOptions.readme.get())
            if(packageOptions.homepage.isPresent)
                writeField("homepage", packageOptions.homepage.get())
            if(packageOptions.repository.isPresent)
                writeField("repository", packageOptions.repository.get())
            if(packageOptions.license.isPresent)
                writeField("license", packageOptions.license.get())
            if(packageOptions.licenseFile.isPresent)
                writeField("license-file", packageOptions.licenseFile.get())
            if(packageOptions.keywords.isPresent)
                writeArrayField("keywords", packageOptions.keywords.get())
            if(packageOptions.categories.isPresent)
                writeArrayField("categories", packageOptions.categories.get())
            if(packageOptions.workspace.isPresent)
                writeField("workspace", packageOptions.workspace.get())
            if(packageOptions.buildFile.isPresent)
                writeField("build", packageOptions.buildFile.get())
            if(packageOptions.links.isPresent)
                writeField("links", packageOptions.links.get())
            if(packageOptions.exclude.isPresent)
                writeArrayField("exclude", packageOptions.exclude.get())
            if(packageOptions.include.isPresent)
                writeArrayField("include", packageOptions.include.get())

            when {
                !packageOptions.publishEnabled.getOrElse(true) -> append("publish = false\n")
                packageOptions.publish.getOrElse(mutableListOf()).isNotEmpty() -> writeArrayField("publish", packageOptions.publish.get())
            }

            if(packageOptions.defaultRun.isPresent)
                writeField("default-run", packageOptions.defaultRun.get())
            if(packageOptions.autoBins.isPresent)
                writeBooleanField("autobins", packageOptions.autoBins.get())
            if(packageOptions.autoExamples.isPresent)
                writeBooleanField("autoexamples", packageOptions.autoExamples.get())
            if(packageOptions.autoTests.isPresent)
                writeBooleanField("autotests", packageOptions.autoTests.get())
            if(packageOptions.autoBenches.isPresent)
                writeBooleanField("autobenches", packageOptions.autoBenches.get())
        }

        if(dependencies.isNotEmpty()) {
            content.writeTable("dependencies") {
                dependencies.forEach { rustCrate ->
                    writeCrateField(rustCrate)
                }
            }
        }

        if(devDependencies.isNotEmpty()) {
            content.writeTable("dev-dependencies") {
                devDependencies.forEach { rustCrate ->
                    writeCrateField(rustCrate)
                }
            }
        }

        if(buildDependencies.isNotEmpty()) {
            content.writeTable("build-dependencies") {
                buildDependencies.forEach { rustCrate ->
                    writeCrateField(rustCrate)
                }
            }
        }

        val libOptions = manifestOptions.libConfig

        if(libOptions.crateType.isPresent && libOptions.crateType.get().isNotEmpty()) content.writeTable("lib") {
            writeField("path", "../${libOptions.path.get()}")
            writeArrayField("crate-type", libOptions.crateType.get())
        }

        val previousBinaries = mutableListOf<String>()

        rustBinaryOptions.get().list.forEach { binary ->
            if(previousBinaries.contains(binary.name.get())) return@forEach
            content.writeTable("[bin]") {
                writeField("name", binary.name.get())
                if(binary.doc.isPresent)
                    writeBooleanField("doc", binary.doc.get())
                if(binary.requiredFeatures.isPresent && binary.requiredFeatures.get().isNotEmpty())
                    writeArrayField("required-features", binary.requiredFeatures.get())
                writeField("path", "../src/main/rust/main.rs")
            }
            previousBinaries.add(binary.name.get())
        }

        //TODO: Resolve custom registries
        /*writeTable(content, "registries") {
            writeField("path", libOptions.path)
            writeArrayField("crate-type", libOptions.crateType)
        }*/

        if(featuresList.get().isNotEmpty()) {
            content.writeTable("features") {
                featuresList.get().forEach { (key, values) ->
                    writeArrayField(key, values, true)
                }
            }
        }

        cargoToml.writeText(content.removePrefix("\n").toString())
    }
}