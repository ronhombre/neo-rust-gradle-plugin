package asia.hombre.neorust.task

import asia.hombre.neorust.CrateLibrary
import asia.hombre.neorust.internal.CargoDefaultTask
import asia.hombre.neorust.options.RustBinaryOptions
import asia.hombre.neorust.options.RustFeaturesOptions
import asia.hombre.neorust.options.RustManifestOptions
import asia.hombre.neorust.options.RustProfileOptions
import org.gradle.api.provider.MapProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Input
import writeArrayField
import writeBooleanField
import writeCrateField
import writeField
import writeTable
import javax.inject.Inject

/**
 * Generate a Cargo-compatible `Cargo.toml` which is used when `cargo` is run.
 *
 * @since 0.2.0
 * @author Ron Lauren Hombre
 */
abstract class CargoManifestGenerate @Inject constructor(): CargoDefaultTask() {

    @get:Input
    abstract val crateLibrary: Property<CrateLibrary>
    @get:Input
    abstract val rustManifestOptions: Property<RustManifestOptions>
    @get:Input
    abstract val rustProfileOptions: Property<RustProfileOptions>
    @get:Input
    abstract val rustFeaturesOptions: Property<RustFeaturesOptions>
    @get:Input
    abstract val rustBinaryOptions: Property<RustBinaryOptions>
    @get:Input
    abstract val featuresList: MapProperty<String, List<String>>

    override fun cargoTaskAction() {
        val cargoToml = manifestPath.get().asFile
        //Create parent directories if they don't exist.
        cargoToml.parentFile.mkdirs()
        //Delete old Cargo.toml since it might be outdated.
        if(cargoToml.exists()) cargoToml.delete()

        val manifestOptions = rustManifestOptions.get()
        val dependencies = crateLibrary.get().dependencies
        val devDependencies = crateLibrary.get().devDependencies
        val buildDependencies = crateLibrary.get().buildDependencies

        val content = StringBuilder()
        val packageOptions = manifestOptions.packageConfig

        content.append(
            """
                # THIS FILE IS AUTO-GENERATED by neo-rust-gradle-plugin
                # MODIFY YOUR build.gradle.kts/build.gradle FILE INSTEAD!
                # CHANGES HERE WILL BE LOST!!!
            """.trimIndent()
        )


        content.writeTable("package") {
            if(!packageOptions.name.isPresent)
                throw IllegalArgumentException("Package 'name' cannot be unset.")

            writeField("name", packageOptions.name.get())
            if(packageOptions.version.isPresent)
                writeField("version", packageOptions.version.get())
            if(packageOptions.authors.isPresent)
                writeArrayField("authors", packageOptions.authors.get())
            if(packageOptions.edition.isPresent)
                writeField("edition", packageOptions.edition.get())
            if(packageOptions.rustVersion.isPresent)
                writeField("rust-version", packageOptions.rustVersion.get())
            if(packageOptions.description.isPresent)
                writeField("description", packageOptions.description.get())
            if(packageOptions.documentation.isPresent)
                writeField("documentation", packageOptions.documentation.get())
            if(packageOptions.readme.isPresent)
                writeField("readme", packageOptions.readme.get())
            if(packageOptions.homepage.isPresent)
                writeField("homepage", packageOptions.homepage.get())
            if(packageOptions.repository.isPresent)
                writeField("repository", packageOptions.repository.get())
            if(packageOptions.license.isPresent)
                writeField("license", packageOptions.license.get())
            if(packageOptions.licenseFile.isPresent)
                writeField("license-file", packageOptions.licenseFile.get())
            if(packageOptions.keywords.isPresent)
                writeArrayField("keywords", packageOptions.keywords.get())
            if(packageOptions.categories.isPresent)
                writeArrayField("categories", packageOptions.categories.get())
            if(packageOptions.workspace.isPresent)
                writeField("workspace", packageOptions.workspace.get())
            if(packageOptions.buildFile.isPresent)
                writeField("build", packageOptions.buildFile.get())
            if(packageOptions.links.isPresent)
                writeField("links", packageOptions.links.get())
            if(packageOptions.exclude.isPresent)
                writeArrayField("exclude", packageOptions.exclude.get())
            if(packageOptions.include.isPresent)
                writeArrayField("include", packageOptions.include.get())

            when {
                !packageOptions.publishEnabled.getOrElse(true) -> append("publish = false\n")
                packageOptions.publish.getOrElse(mutableListOf()).isNotEmpty() -> writeArrayField("publish", packageOptions.publish.get())
            }

            if(packageOptions.defaultRun.isPresent)
                writeField("default-run", packageOptions.defaultRun.get())
            if(packageOptions.autoBins.isPresent)
                writeBooleanField("autobins", packageOptions.autoBins.get())
            if(packageOptions.autoExamples.isPresent)
                writeBooleanField("autoexamples", packageOptions.autoExamples.get())
            if(packageOptions.autoTests.isPresent)
                writeBooleanField("autotests", packageOptions.autoTests.get())
            if(packageOptions.autoBenches.isPresent)
                writeBooleanField("autobenches", packageOptions.autoBenches.get())
        }

        if(rustProfileOptions.get().dev.get().isNotEmpty()) content.writeTable("profile.dev") {
            rustProfileOptions.get().dev.get().forEach { dev ->
                writeField(dev.key, dev.value)
            }
        }

        if(rustProfileOptions.get().release.get().isNotEmpty()) content.writeTable("profile.release") {
            rustProfileOptions.get().release.get().forEach { release ->
                writeField(release.key, release.value)
            }
        }

        if(rustProfileOptions.get().test.get().isNotEmpty()) content.writeTable("profile.test") {
            rustProfileOptions.get().test.get().forEach { test ->
                writeField(test.key, test.value)
            }
        }

        if(rustProfileOptions.get().bench.get().isNotEmpty()) content.writeTable("profile.bench") {
            rustProfileOptions.get().bench.get().forEach { bench ->
                writeField(bench.key, bench.value)
            }
        }

        rustFeaturesOptions.get().list.addAll(featuresList.get().map { feature ->
            RustFeaturesOptions.Feature(feature.key, feature.value)
        })

        if(rustFeaturesOptions.get().list.isNotEmpty()) {
            content.writeTable("features") {
                rustFeaturesOptions.get().list.forEach { feature ->
                    writeArrayField(feature.name, feature.values, true)
                }
            }
        }

        if(dependencies.isNotEmpty()) {
            content.writeTable("dependencies") {
                dependencies.forEach { rustCrate ->
                    writeCrateField(rustCrate)
                }
            }
        }

        if(devDependencies.isNotEmpty()) {
            content.writeTable("dev-dependencies") {
                devDependencies.forEach { rustCrate ->
                    writeCrateField(rustCrate)
                }
            }
        }

        if(buildDependencies.isNotEmpty()) {
            content.writeTable("build-dependencies") {
                buildDependencies.forEach { rustCrate ->
                    writeCrateField(rustCrate)
                }
            }
        }

        val libOptions = manifestOptions.libConfig

        if(libOptions.crateType.isPresent && libOptions.crateType.get().isNotEmpty()) content.writeTable("lib") {
            writeField("path", "../${libOptions.path.get()}")
            writeArrayField("crate-type", libOptions.crateType.get())
        }

        val previousBinaries = mutableListOf<String>()

        rustBinaryOptions.get().list.forEach { binary ->
            if(previousBinaries.contains(binary.name.get())) return@forEach
            content.writeTable("[bin]") {
                writeField("name", binary.name.get())
                if(binary.doc.isPresent)
                    writeBooleanField("doc", binary.doc.get())
                if(binary.requiredFeatures.isPresent && binary.requiredFeatures.get().isNotEmpty())
                    writeArrayField("required-features", binary.requiredFeatures.get())
                writeField("path", "../src/main/rust/main.rs")
            }
            previousBinaries.add(binary.name.get())
        }

        //TODO: Resolve custom registries
        /*writeTable(content, "registries") {
            writeField("path", libOptions.path)
            writeArrayField("crate-type", libOptions.crateType)
        }*/

        /*if(featuresList.get().isNotEmpty()) {
            content.writeTable("features") {
                featuresList.get().forEach { (key, values) ->
                    writeArrayField(key, values, true)
                }
            }
        }*/

        cargoToml.writeText(content.removePrefix("\n").toString())
    }
}